---
title: "The Betlab Project"
author: "Tobias Diederich"
date: "Saturday, October 31, 2015"
output: pdf_document
---

## Abstract

The Betlab Project aims to predict the outcome of football matches. The predictions are compared with booky odds to place value bets. To predict the outcome, the market prices of the participating players are analysed because they are assumed to represent the base quality of a player.
The main metric to evaluate model performance is the simulated earning with respect to the booky odds.

I show the high potential of my approach, even if it is not yet practicable.

## Data

The match, team and player data are collected from [Transfermarkt](http://www.transfermarkt.de/). Booky odds are collected from [Sfstats](http://de.sfstats.net/). The parsers are written in Java and are not part of this paper.

Relevant data will be of germanies 1. Bundesliga from season 2005-2006 to 2014-2015.

```{r warning=FALSE, message=FALSE, cache=TRUE}
source(file = 'production/loadData.R', echo = FALSE, encoding = 'UTF-8') 
toMatchday <- 34
seasons <- c('2005-2006', '2006-2007', '2007-2008', '2008-2009', '2009-2010',
             '2010-2011', '2011-2012', '2012-2013', '2013-2014', '2014-2015')
leagues <- c('BL1')
trainingRaw <- loadTrainingData(toMatchday = toMatchday, seasons = seasons, leagues = leagues)
matches <- trainingRaw$matches
odds <- trainingRaw$odds
stats <- trainingRaw$stats
```


### Datasets

matches -> contains all matches   
odds -> contains booky odds and probabilies for all matches  
stats -> an observation contains information for one player in one match  

```{r warning=FALSE, message=FALSE}
describe(select(matches, goalsHome, goalsVisitors, matchResult))
describe(select(odds, HomeVictory, VisitorsVictory, Draw))
describe(select(stats, fitPrice, position, playerAssignment, formation))
```

## Feature Engineering

The features I extract are the marketprices of participating players aggregated by team, grouped position and aggregation method.
Participating players are those who played the whole match, came from the bench or got substituted. Grouped positions are goaly, defense, midfield and offense. Aggregation methods are: min, max, mean and sum.

```{r warning=FALSE, message=FALSE, cache=TRUE}
source('production/positionFeatureExtraction.R', 
       echo = FALSE, encoding = 'UTF-8')
### Preparation
#[1] "Torwart"               "Innenverteidiger"      "Linker Verteidiger"    "Rechter Verteidiger"   "Defensives Mittelfeld"
#[6] "Zentrales Mittelfeld"  "Linkes Mittelfeld"     "Rechtes Mittelfeld"    "Offensives Mittelfeld" "Haengende Spitze"     
#[11] "Mittelstuermer"        "Linksaussen"           "Rechtsaussen"
positions <- c('tw', 'def', 'def', 'def', 'mid', 'mid', 'mid', 'mid', 'off', 'off', 'off', 'off', 'off')
relNormalAssignments <- c('DURCHGESPIELT', 'EINGEWECHSELT', 'AUSGEWECHSELT')
normalMatches <- extractMatchResultFeatures(playerStats = stats,
                                            matches = matches,
                                            priceAssignedPositions = positions,
                                            functs = c('min', 'max', 'avg', 'sum'), 
                                            relNormalAssignments)

filteredNormalMatches <- filterFeaturedMatches(normalMatches)
```


```{r warning=FALSE, message=FALSE}
explMatches <- select(filteredNormalMatches, -matchId, -matchResult, -goalDiff)
# Features:
colnames(explMatches)
```

```{r warning=FALSE, message=FALSE}
library(magrittr)
library(tidyr)
explGathered <- explMatches %>% gather(feature, value)

getGroupStr <- function(feature, group) {
    charList <- strsplit(as.character(feature), '_')
    charFrame <- data.frame(do.call(rbind, charList))
    if(group == 'func') {
        return(charFrame[, 4])
    } else if(group == 'pos') {
        return(charFrame[, 1])
    } else {
        return(NA)
    }
}
groupedMatches <- mutate(explGathered, funct = factor(getGroupStr(feature, 'func')),
                         position = factor(getGroupStr(feature, 'pos')))
avgPlot <- ggplot(filter(groupedMatches, funct == 'avg'), aes(x = position, y = value, fill = position)) +
    geom_boxplot() +
    ggtitle('Avg Prices of players by position') +
    coord_cartesian(ylim = c(0, 10000000))
avgPlot
```

## Model fitting

```{r warning=FALSE, message=FALSE}
seed <- 1834
tcontr = trainControl(method = 'cv', number = 20, classProbs = TRUE)
train <- dplyr:::select(filteredNormalMatches, -goalDiff)
resultFormula <- as.Formula('matchResult ~ . - matchId')
set.seed(seed)
polrModel <- train(resultFormula, data = train, method = 'polr',
                   preProcess = c('center', 'scale'),
                   trControl = tcontr)
polrModel
```

## Evaluate model in comparison to booky odds

To evaluate the predictions, matches have to be predicted iteratively. For this all matches are split in 10 disjunctive validation sets. In every of the 10 iterations, a model is trained and used to predict the observations in the corresponding validation set.

```{r warning=FALSE, message=FALSE}
source(file = 'production/models.R', 
       echo = FALSE, encoding = 'UTF-8')
test <- dplyr:::select(filteredNormalMatches, -goalDiff)
noneContr = trainControl(method = 'none')
folds <- 10
splits <- splitMatches(matchesToSplit = test, 
                       testingMatches = test, folds = folds, seed = seed)

allPredictions <- iterativelyPredict(splits, folds, 
                                     resultFormula, meth = 'polr', 
                                     prePr = c('center', 'scale'), 
                                     tControl = noneContr, seed = seed)

source(file = 'evaluatePrediction.R', 
       echo = FALSE, encoding = 'UTF-8')

evaluations <- evaluatePrediction(prediction = allPredictions, 
                                  comparison = odds, 
                                  probRatioToBet = 1.1, stake = 1)
printEvaluation(evaluations)
```

22 % earning is very good, the problem is, that for this calculation it is necessary to know all playing players. This is not possible in practice, you just know the starting lineup.

## Prediction with just the starting lineup

This time only the players in the starting lineup are considered.

```{r warning=FALSE, message=FALSE}
relPredAufstellungAssignments <- c('DURCHGESPIELT', 'AUSGEWECHSELT')
predAufstellungMatches <- extractMatchResultFeatures(playerStats = stats,
                                                     matches = matches,
                                                     priceAssignedPositions = positions,
                                                     functs = c('min', 'max', 'avg', 'sum'), 
                                                     relPredAufstellungAssignments)
filteredPredAufstellungMatches <- filterFeaturedMatches(predAufstellungMatches)

aufstTest <- dplyr:::select(filteredPredAufstellungMatches, -goalDiff)
aufstSplits <- splitMatches(matchesToSplit = aufstTest, 
                       testingMatches = aufstTest, folds = folds, seed = seed)

allPredictions <- iterativelyPredict(aufstSplits, folds, 
                                     resultFormula, meth = 'polr', 
                                     prePr = c('center', 'scale'), 
                                     tControl = noneContr, seed = seed)

aufstEvaluations <- evaluatePrediction(prediction = allPredictions, 
                                  comparison = odds, 
                                  probRatioToBet = 1.1, stake = 1)
printEvaluation(aufstEvaluations)
```

